exec可以动态调用函数
    def f(x):
      print（x)
    exec('for i in range(9):f(x)')
    
====================================================================

list和dict的copy:
>>> import copy
>>> origin = [1, 2, [3, 4]]
#origin 里边有三个元素：1， 2，[3, 4]
>>> cop1 = copy.copy(origin)
>>> cop2 = copy.deepcopy(origin)
>>> cop1 == cop2
True
>>> cop1 is cop2
False 
#cop1 和 cop2 看上去相同，但已不再是同一个object
>>> origin[2][0] = "hey!" 
>>> origin
[1, 2, ['hey!', 4]]
>>> cop1
[1, 2, ['hey!', 4]]
>>> cop2
[1, 2, [3, 4]]
#把origin内的子list [3, 4] 改掉了一个元素，观察 cop1 和 cop2
    
====================================================================

list的append,extend，sort等函数都直接修改list，返回None
复制list可以用d1=d[:]，直接用d2=d的话是直接引用d了

    
====================================================================

字符串全部替换
>>> tr=''.maketrans('ab','2笔')
>>> 'asbadbj'.translate(tr)

====================================================================

fromkeys可以用dict快速生成dict
>>> d
{1: 'a', 2: 'b', 3: [0, 'd', 'e'], 4: 44}
>>> d.fromkeys(d)
{1: None, 2: None, 3: None, 4: None}
>>> d.fromkeys(d,'good')
{1: 'good', 2: 'good', 3: 'good', 4: 'good'}
    
====================================================================

zip：打包
>>> dict(zip(range(3),'asd'))
{0: 'a', 1: 's', 2: 'd'}
filter：过滤，返回x%2！=0
>>> list(filter(lambda x:x%2,range(9)))
[1, 3, 5, 7]
map：对迭代器每个值计算
>>> list(map(lambda x:x%2,range(9)))
[0, 1, 0, 1, 0, 1, 0, 1, 0]
reduce：对每个值计算，最后得到一个值
>>> reduce(lambda x,y:y+x,'huaq!')
'!qauh'
    
====================================================================

globals()是全局变量的dict
>>> q=1
>>> def f(q):
	q='aa'
	print(q,globals()['q'])
>>> f(q)
aa 1
    
====================================================================

断言assert
>>> for i in range(9):
	print(i)
	assert i<3	
0
1
2
3
Traceback (most recent call last):
  File "<pyshell#438>", line 3, in <module>
    assert i<3
AssertionError

====================================================================

>>> import fileinput
>>> for i in open('1.txt').readlines():
	i
'123 456\n'
'\n'
'789  \n'
'  俺是\n'
'\n'
'asdd\n'
'a\n'
'\t1\t\n'
'6d\n'
'a\n'
'\t1\t\n'
'6'
>>> for i in fileinput.input('1.txt'):
	i	
'123 456\n'
'\n'
'789  \n'
'  俺是\n'
'\n'
'asdd\n'
'a\n'
'\t1\t\n'
'6d\n'
'a\n'
'\t1\t\n'
'6'

====================================================================

#类和实例，访问限制

	class Student(object):
	    def __init__(self, name, score):
		self.name = name
		self.score = score

	    def get_grade(self):
		if self.score >= 90:
		    return 'A'
		elif self.score >= 60:
		    return 'B'
		else:
		    return 'C'
		 
如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，
就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：

class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
	
改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：

>>> bart = Student('Bart Simpson', 59)
>>> bart.__name
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute '__name'

这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。
但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：

class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
	
如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：

class Student(object):
    ...

    def set_score(self, score):
        self.__score = score

====================================================================

class Animal(object):
    def run(self):
        print('Animal is running...')
	
class Dog(Animal):

    def run(self):
        print('Dog is running...')

class Cat(Animal):

    def run(self):
        print('Cat is running...')
	
====================================================================
